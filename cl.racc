#  racc  cl.racc

class ClParser
rule

  program   : stmt_list
                {
#                  result = RootNode.new(val[0])
                }

  stmt_list :
                {
#                  result = []
                }
            | stmt_list stmt EOL
                {
#                  result.push val[1]
                }
            | stmt_list EOL

  stmt      : PGM
            | COMMAND parms
            | ENDPGM

  parms     : parms parm
            | parm

  parm      : PARM '(' primary ')'
            | PARM '(' primary '(' primary primary ')' ')'
            | PARM '(' COMMAND PGM '(' IDENT ')' ')'

  primary   : IDENT
                {
#                  result = VarRefNode.new(@file_name, val[0][0], val[0][1])
                }
            | NUMBER
                {
#                  result = LiteralNode.new(@file_name, val[0][0], val[0][1])
                }
            | RESERVED
            | IDENT '/' IDENT

end

---- header ----
#
# generated by racc
#
require './cl.rex.rb'

---- inner ----

  def parse(file, file_name)
    @file_name = file_name
    @q = ClLexer.new
    @q.load_file(file_name)
    @yydebug = true
    do_parse
  end

  def next_token
    @q.next_token
  end

  def on_error(t, v, values)
    if v
      line = v[0]
      v = v[1]
    else
      line = 'last'
    end
    raise Racc::ParseError, "#{@file_name}:#{line}: syntax error on #{v.inspect}"
  end
