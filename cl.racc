# racc -v -g cl.racc

class ClParser

options no_result_var

prechigh
  left '||'
  nonassoc '='
preclow

rule

  program   : stmt_list
                {
                  RootNode.new(val[0])
                }

  stmt_list :
                {
                  result = []
                }
            | stmt_list stmt EOL
                {
                  val[0].push val[1]
                }
            | stmt_list EOL

  stmt      : command
            | label command
                {
                  val[1]
                }
            | if_stmt

  command   : IDENT parms
                {
                  CommandNode.new(@file_name, val[0][0], val[0][1], val[1])
                }
            | IDENT args
                {
                  CommandNode.new(@file_name, val[0][0], val[0][1], val[1])
                }
            | IDENT
                {
                  CommandNode.new(@file_name, val[0][0], val[0][1], nil)
                }

  label     : IDENT ':'

  if_stmt   : IF COND '(' expr ')' THEN '(' command ')'
                {
                  IfNode.new(@file_name, val[0][0], val[3], val[7])
                }

  parms     : parm
                {
                  [val[0]]
                }
            | parms parm
                {
                  val[0].push(val[1])
                }

  parm      : IDENT '(' args ')'
                {
                  ParmNode.new(@file_name, val[0][0], val[0][1], val[2])
                }
            | IDENT '(' primary '(' NUMBER NUMBER ')' ')' # 例.DTAARA(WRKLIB/AREA1 (1 7))
            | CMD '(' IDENT IDENT  '(' IDENT ')' ')'      # 例.CMD(CALL PGM(PGM1A))

  args      : primary
                {
                  [val[0]]
                }
            | args primary
                {
                  val[0].push(val[1])
                }
 
  primary   : IDENT
                {
                  LiteralNode.new(@file_name, val[0][0], val[0][1])
                }
            | NUMBER
                {
                  LiteralNode.new(@file_name, val[0][0], val[0][1])
                }
            | STRING
                {
                  StringNode.new(@file_name, val[0][0], val[0][1])
                }
            | RESERVED
                {
                  ReservedNode.new(@file_name, val[0][0], val[0][1])
                }
            | IDENT '/' IDENT
                {
                  LiteralNode.new(@file_name, val[0][0], val[0][1].to_s + '/' + val[0][2].to_s)
                }
            | function
            | expr

  expr      : primary '=' primary
                {
                  LiteralNode.new(@file_name, val[0].lineno, '=')
                }
            | primary '||' primary
                {
                  LiteralNode.new(@file_name, val[0].lineno, '||')
                }

  function  : SST '(' args ')'
                {
                  FuncallNode.new(@file_name, val[0][0], '[]', [val[1], val[3]])
                }

end

---- header ----
#
# generated by racc
#
require './cl.rex.rb'

---- inner ----

  def parse(file, file_name)
    @file_name = file_name
    @q = ClLexer.new
    @q.load_file(file_name)
    @yydebug = true
    do_parse
  end

  def next_token
    @q.next_token
  end

  def on_error(t, v, values)
    if v
      line = v[0]
      v = v[1]
    else
      line = 'last'
    end
    raise Racc::ParseError, "#{@file_name}:#{line}: syntax error on #{v.inspect}"
  end
